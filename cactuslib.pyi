from _typeshed import Incomplete
from base_plugin import BasePlugin, HookResult as HookResult, HookStrategy as HookStrategy, MenuItemData as MenuItemData, MenuItemType as MenuItemType, MethodHook
from contextlib import contextmanager
from dataclasses import dataclass
from enum import Enum
from org.telegram.messenger import MessageObject
from typing import Any, Callable, final

__all__ = ['CactusUtils', 'command', 'uri', 'HookResult', 'HookStrategy', 'MenuItemData', 'MenuItemType']


class CactusUtils:
    class Callback(Incomplete):
        def __init__(self, fn: Callable[[Any], None], *args, **kwargs) -> None: ...
        def run(self, arg) -> None: ...
    
    @dataclass
    class Command:
        command: str
        args: list[str]
        raw_args: str | None
        text: str
        account: int
        params: Any
    class FileSystem:
        File = File
        @classmethod
        def basedir(cls): ...
        @classmethod
        def cachedir(cls): ...
        @classmethod
        def tempdir(cls): ...
        @classmethod
        def get_file_content(cls, file_path, mode: str = 'rb'): ...
        @classmethod
        def get_temp_file_content(cls, filename: str, mode: str = 'rb', delete_after: int = 0): ...
        @classmethod
        def write_file(cls, file_path, content, mode: str = 'wb'): ...
        @classmethod
        def write_temp_file(cls, filename: str, content, mode: str = 'wb', delete_after: int = 0): ...
        @classmethod
        def delete_file_after(cls, file_path, seconds: int = 0): ...
    @classmethod
    def compress_and_encode(cls, data: bytes, level: int = 7) -> str: ...
    @staticmethod
    def decode_and_decompress(encoded_data: bytes): ...
    @staticmethod
    def pluralization_string(number: int, words: list[str]): ...
    @classmethod
    def initialize_plugin(cls, plugin: BasePlugin): ...
    @classmethod
    def unload_plugin(cls, plugin: BasePlugin): ...
    @staticmethod
    def escape_html(text: str): ...
    @staticmethod
    def show_error(message: str): ...
    @staticmethod
    def show_info(message: str): ...
    @staticmethod
    def copy_to_clipboard(text: str): ...
    @classmethod
    def prefix(cls): ...
    @classmethod
    def get_locale(cls): ...
    @staticmethod
    def log(message: str, level: str = 'INFO', __id__: str | None = ...): ...
    @staticmethod
    def debug(message: str, __id__: str | None = ...): ...
    @staticmethod
    def error(message: str, __id__: str | None = ...): ...
    @staticmethod
    def info(message: str, __id__: str | None = ...): ...
    @staticmethod
    def warn(message: str, __id__: str | None = ...): ...
    @staticmethod
    def runtime_exec(command: list[str], return_list_lines: bool = False, raise_errors: bool = True) -> list[str] | str: ...
    @staticmethod
    def get_logs(__id__: str | None = None, time: int | None = None, lvl: str | None = None, as_list: bool = False): ...
    @classmethod
    def parse_message(cls, text: str, parse_mode: str) -> dict[str, Any]: ...
    @classmethod
    def array_list(cls, *args): ...
    @classmethod
    def send_message(cls, peer: int, text: str, parse_message: bool = True, parse_mode: str = 'MARKDOWN', **kwargs): ...
    @classmethod
    def open_plugin_settings(cls, plugin_id: str): ...
    @dataclass
    class Uri:
        plugin_id: str
        command: str
        kwargs: dict[str, str]
        @classmethod
        def create(cls, plugin, command: str, **kwargs): ...
        def string(self): ...
    @classmethod
    def edit_message(cls, message_object: MessageObject, text: str, parse_message: bool = True, parse_mode: str = 'MARKDOWN', **kwargs): ...
    class CactusModule(BasePlugin):
        utils: CactusUtils
        __min_lib_version__: str
        def __init__(self) -> None: ...
        strings: dict[str, dict[str, str]]
        def export_data(self) -> dict[str, Any]: ...
        def import_data(self, data) -> None: ...
        def on_plugin_load(self) -> None: ...
        def on_plugin_unload(self) -> None: ...
        def open_plugin_settings(self) -> None: ...
        @final
        def lstrings(self) -> dict[str, str]: ...
        @final
        def string(self, key: str, *args, default: str | None = None, locale: str = None, **kwargs) -> str: ...
        @final
        def log(self, message: str, level: str = 'INFO'): ...
        @final
        def debug(self, message: str): ...
        @final
        def error(self, message: str): ...
        @final
        def info(self, message: str): ...
        @final
        def warn(self, message: str): ...
        @final
        def on_send_message_hook(self, account, params): ...
        @final
        def on_uri_command_hook(self, cmd: str, kwargs: dict[str, Any]): ...
        @final
        def answer(self, params, text: str, *, parse_message: bool = True, parse_mode: str = 'MARKDOWN', **kwargs): ...
        @final
        def edit_message(self, params, text: str, parse_message: bool = True, parse_mode: str = 'MARKDOWN', **kwargs): ...
        @final
        def answer_file(self, peer: int, path: str, caption: str | None = None, *, parse_message: bool = True, parse_mode: str = 'MARKDOWN', **kwargs): ...
        @final
        def answer_photo(self, params, path: str, caption: str | None = None, *, parse_message: bool = True, edit_params: bool = False, **kwargs): ...
    Plugin = CactusModule
    CactusPlugin = CactusModule
    class Telegram:
        @staticmethod
        def tlrpc_object(request_class, **kwargs): ...
        class SearchFilter(Enum):
            GIF = 'gif'
            MUSIC = 'music'
            CHAT_PHOTOS = 'chat_photos'
            PHOTOS = 'photos'
            URL = 'url'
            DOCUMENT = 'document'
            PHOTO_VIDEO = 'photo_video'
            PHOTO_VIDEO_DOCUMENT = 'photo_video_document'
            GEO = 'geo'
            PINNED = 'pinned'
            MY_MENTIONS = 'my_mentions'
            ROUND_VOICE = 'round_voice'
            CONTACTS = 'contacts'
            VOICE = 'voice'
            VIDEO = 'video'
            PHONE_CALLS = 'phone_calls'
            ROUND_VIDEO = 'round_video'
            EMPTY = 'empty'
            def to_TLRPC_object(self): ...
        @classmethod
        def search_messages(cls, callback: Callable[[list[MessageObject], Any], None], dialog_id: int, query: str | None = None, from_id: int | None = None, offset_id: int = 0, limit: int = 20, reply_message_id: int | None = None, top_message_id: int | None = None, filter: SearchFilter = ...): ...
        @staticmethod
        def get_user(user_id: int): ...
        @staticmethod
        def peer(peer_id: int): ...
        @staticmethod
        def input_peer(peer_id: int): ...
        @staticmethod
        def get_channel(callback: Callable[[Any, Any], None], channel_id: int) -> int: ...
        @staticmethod
        def get_chat(callback: Callable[[Any, Any], None], chat_id: int) -> int: ...
        @classmethod
        def create_input_location(cls, photo, size): ...
        @classmethod
        def create_peer_input_location(cls, chat, peer): ...
        @classmethod
        def get_chat_thumbnail(cls, callback: Callable[[Any, Any], None], chat, peer) -> int: ...
        @classmethod
        def get_user_photos(cls, callback: Callable[[Any, Any], None], user_id: int, limit: int = 1) -> int: ...
        @classmethod
        def delete_messages(cls, messages: list[int], chat_id: int, topic_id: int = 0): ...
        @classmethod
        def get_sticker_set_by_short_name(cls, callback: Callable[[Any, Any], None], short_name: str) -> int: ...
    @classmethod
    def get_message_by_rnd_in_current_chat(cls, rnd: str, fn: Callable[[MessageObject, Any], None]): ...
    @contextmanager
    def SpinnerAlertDialog(self, text: str | None = None): ...

def command(command: str | None = None, *, aliases: list[str] | None = None, doc: str | None = None, enabled: str | bool | None = None): ...
def uri(uri: str): ...
